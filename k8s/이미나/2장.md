## 쿠버네티스는 어떻게 컨테이너를 실행하고 관리할까?

**컨테이너란?**

애플리케이션 구성 요소 하나를 실행하는 가상화된 환경

k8s는 이 컨테이너를 또 다른 가상 환경인 파드로 감싼다.

**파드**

- 쿠버네티스가 하나 또는 그 이상의 컨테이너를 관리하는데 사용하는 단위
- 모든 컨테이너는 파드에 속함 → 파드에 포함되면 네트워크 공유
- 컨테이너의 세부 사항을 추상화해 자가수복형 애플리케이션이나 바람직한 상태 워크플로 가능
- 디플로이먼트가 관리
- 클러스터를 이루는 노드 중 하나에서 실행됨
- 쿠버네티스로 관리되는 자신만의 가상 IP 주소를 가짐 → 이 주소로 다른 파드나 노드에서 실행되는 파드와 통신 가능

**쿠버네티스는 직접 컨테이너를 실행하지 않는다.**

→ 컨테이너를 생성할 책임을 해당 노드에 설치된 컨테이너 런타임(도커 등)에 맡긴다.

**관리 담당**

파드 → 쿠버네티스가 관리

컨테이너 → 쿠버니테스 외부에서 관리

**kubectl**

- 명령어에 관심 있는 출력 내용에 대한 질의를 지정하는데 용이
- 리소스 정보 중 원하는 정보에 마음대로 접근 가능
- 자동화 시킬때 편리함

파드는 파드를 생성할 때 한 노드에 배정된다.

→ 이 파드를 관리하고 파드에 포함된 컨테이너를 실행하는 책임도 노드

→ 이 과정은 컨테이너 런타임 인터페이스를 이용해 컨테이너 런타임과 연동되는 형태로 진행

→ 어떤 컨테이너 런타임을 실행 중이더라도 같은 방식으로 노드 관리 가능

컨테이너를 파드로 추상화해 컨테이너가 이상을 일으켜도 일시적인 문제일 뿐 파드는 그대로 있어, 새로운 컨테이너를 추가해 파드 상태를 복원하면 해결 가능하다.

파드 위로 더 쌓일 추상화를 통해 애플리케이션은 이 이상의 복원력을 가질 수 있다.

ex) 디플로이먼트 → 파드 위로 얹히는 또 다른 추상화

## 컨트롤러 객체

**컨트롤러 객체**

- 다른 리소스를 관리하는 쿠버네티스 리소스
- 컨트롤러는 쿠버네티스 API와 연동하며 시스템의 현재 상태를 감시하다가 바람직한 상태와 차이가 생기면 필요에 따라 그 차이를 바로잡음
- 파드를 주로 관리하는 컨프롤러 객체는 디플로이먼트
- 디플로이먼트를 스케일링하고 싶으면 필요 파드 수 지정
- 레이블 셀렉터를 통해 자신이 관리하는 리소스인지 판단함

디플로이먼트는 쿠버네티스 API를 통해 현재 동작 중인 리소스가 무엇이 있는지 살펴보고, 자신이 관리해야 할 파드가 없다는 사실을 발견하여 다시 쿠버네티스 API를 통해 자신에게 필요한 파드 생성

→ 요약 : **디플로이먼트만 만들면 우리에게 필요한 파드를 대신 만들어준다**

디플로이먼트가 자신이 관리해야 할 리소스를 어떻게 추적할까?

- 모든 쿠버네티스 리소스는 간단한 키-값 쌍 형태의 레이블을 가짐
- 이 레이블에 원하는 데이터를 담음
- 레이블은 객체 간 관계를 표현해서 리소스와 리소스의 느슨한 연결을 만드는 데도 쓰임

컨트롤러가 자신이 관리하는 리소스 목록을 직접 유지하지 않아도, **레이블 셀렉터가 컨트롤러 객체의 정의에 포함**되어 있기 대문에 컨트롤러 객체가 언제라도 k8s API를 통해 자신이 관장하는 리소스를 찾아볼 수 있다.

→하지만 레이블 정보를 함부로 직접 수정하다간 리소스 간 관계를 흐트러트릴 수 있다.

디플로이먼트는 파드와 직접적인 관계를 가지지 않는다. 그래서 **레이블 셀렉터와 일치하는 파드**가 하나 있기만 하면 된다.

→ 파드의 레이블이 수정된다면 디플로이먼트는 해당 파드를 더 이상 인지하지 못함

→ 레이블 셀렉터와 일치하는 파드가 사라져 새로운 파드를 만들어버린다.

만약 수정된 레이블을 다시 돌려놓는다면?

- 디플로이먼트는 k8s API를 통해 레이블 셀렉터와 일치하는 파드 수가 2개가 된 것을 확인
- 자신의 정의상 파드 하나만 유지하면 되므로 그 중 하나를 삭제(삭제 규칙에 따라 결정)

파드는 컨테이너와 마찬가지로 생애 주기가 짧다

## 애플리케이션 매니페스트

**애플리케이션 매니페스트**

- YAML을 많이 씀(좋은 가독성과 파일 하나에 많은 리소스를 정의할 수 있다.)
- 선언적 스크립트
    - 최종 결과가 어떻게 되어야 하는지 알려 주고 그 최종 결과를 만드는 과정은 따지지 않는다.
- 매니페스트 파일이 있어도 애플리케이션을 배포하려면 kubectl apply 사용
- YAML로 파일 작성 시 디플로이먼트가 실행할 파드의 정의를 필수적으로 작성해야 함

## 파드에서 실행 중인 애플리케이션에 접근하기

파드와 디플로이먼트가 애플리케이션의 가용성을 확보하더라도, 실제 애플리케이션은 컨테이너 속에서 동작한다.

컨테이너 런타임에 따라 직접적인 컨테이너 접근을 허용하지 않을 수도 있는데 kubectl을 사용하면 접근할 수 있다.

## 리소스 관리

kubectl을 사용하면 리소스를 쉽게 삭제할 수 있지만, 삭제한 리소스가 되살아나는 경우가 있다.

컨트롤러 객체가 만든 리소스의 삭제는 해당 컨트롤러 객체의 책임이다.

`kubectl delete pods --all` 을 하고 다시 파드를 조회해보면?

- 파드를 모두 삭제했는데 다시 생성되었음
- 디플로이먼트가 자신이 관리하던 파드를 대체할 새 파드를 만든 것
- 컨트롤러 객체가 관리하는 리소스를 삭제하려면 해당 컨트롤러 객체를 삭제해야 한다.
- 컨트롤러 객체를 지우면 자신이 관리하던 리소스를 제거하고 삭제된다. → 디플로이먼트도 마찬가지